### Smart Pointers ###

RefPtr:
  kind: Smart Pointer
  traverse:
    - mRawPtr
# Aliases
nsCOMPtr: RefPtr
nsAutoPtr: RefPtr
mozilla::StaticAutoPtr: RefPtr
mozilla::StaticRefPtr: RefPtr

UniquePtr:
  kind: Smart Pointer
  traverse:
    - mTuple
    - mFirstA

### Other MFBT Fancy Stuff ###

mozilla::Atomic:
  kind: Atomic Wrapper
  traverse:
    - mValue
    # XXX/disclaimer: this is the (gcc) std::atomic's implementation fields that
    # we pierce.  If we only did mValue, we end up (for the nsresult case)
    # mozilla::detail::AtomicBase<nsresult, (mozilla::MemoryOrdering)1>::ValueType
    # which clearly can be pierced more, but it's not clear that we need a magic
    # template piercing heuristic for this yet.  Presumably we'll need that when
    # I start building under clang again?
    - _M_i

### XPCOM-ish stuff ###
nsAutoRefCnt:
  kind: RefCount
  terse:
  - mValue: true
  # Can this just be covered by the type name?
  - isThreadSafe: true

nsThread:
  simple:
  - mThread: true
  - mNestedEventLoopDepth: true
  - mStackSize: true

PRThread:
  simple:
  - name: true
  - tid: true


### Containers ###

# Note that the LinkedList is the container, posessing a "sentinel" member.  The
# elements are LinkedListElements.  We only want to print the entire list if we
# find ourselves looking at a LinkedList type.  Printing one member should not
# print all its siblings.
mozilla::LinkedList:
  kind: Collection
  iterate:
    # "sentinel" is the magic that enters into our hard-coded logic for this
    # case.
    sentinel: sentinel
    advance: mNext

### String hacks
# XXX remove this.  nsCString wasn't pretty printing for me in one of my test
# cases, so I added this hack.  As I went to write the commit message, I
# realized the problem is likely that I ran rr from outside the mozilla-central
# tree and so the auto-loading heuristics failed to find the mozilla pretty
# printers.  (I've been doing most of my other dev loop cycle from the right
# location.)  I'm going to leave this in for a little if only because it's an
# interesting edge case.
##nsCString:
##  kind: String
##  traverse:
##  - mData

### Security-ish stuff

ContentPrincipal:
  simple:
  - mCodebase: true
  - mOriginAttributes: true

mozilla::OriginAttributes:
  terse:
  - mPrivateBrowsingId: true
  - mUserContextId: true
  - mFirstPartyDomain: true

### Necko-ish Stuff ###

LOAD_FLAGS:
  bitflags:
    zero: LOAD_NORMAL
    bits:
      # from nsIRequest.idl
      # LOAD_NORMAL is a pure 0 value, covered above.
      - LOAD_BACKGROUND: 0
      - LOAD_HTML_OBJECT_DATA: 1
      - LOAD_DOCUMENT_NEEDS_COOKIE: 2
      - INHIBIT_CACHING: 7
      - INHIBIT_PERSISTENT_CACHING: 8
      - LOAD_BYPASS_CACHE: 9
      - LOAD_FROM_CACHE: 10
      - VALIDATE_ALWAYS: 11
      - VALIDATE_NEVER: 12
      - VALIDATE_ONCE_PER_SESSION: 13
      - LOAD_ANONYMOUS: 14
      - LOAD_FRESH_CONNECTION: 15
      # from nsIChannel.idl
      - LOAD_DOCUMENT_URI: 16
      - LOAD_RETARGETED_DOCUMENT_URI: 17
      - LOAD_REPLACE: 18
      - LOAD_INITIAL_DOCUMENT_URI: 19
      - LOAD_TARGETED: 20
      - LOAD_CALL_CONTENT_SNIFFERS: 21
      - LOAD_CLASSIFY_URI: 22
      - LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE: 23
      - LOAD_EXPLICIT_CREDENTIALS: 24
      - LOAD_BYPASS_SERVICE_WORKER: 25
      # from nsICachingChannel.idl:


mozilla::net::nsStandardURL:
  # XXX this wants to be terse, but we need to rely on the underlying printer
  # for strings and terse bypasses it.
  simple:
  - mSpec: true

mozilla::net::nsHttpRequestHead:
  terse:
  - mMethod: true

mozilla::net::nsLoadGroup:
  simple:
  - mLoadFlags: LOAD_FLAGS

mozilla::net::LoadInfo:
  simple:
  - mLoadingPrincipal: true
  - mOriginAttributes: true

mozilla::net::HttpBaseChannel:
  groups:
  - overview:
    - mRequestHead: true
    - mURI: true
    - mStatus: true
  - context:
    - mOriginalURI: true
    - mDocumentURI: true
  - load:
    - mUploadStream: true
    # should include somehow: mCorsMode, mRedirectMode, mFetchCacheMode
    - mLoadFlags: LOAD_FLAGS
    - mLoadGroup: true
    - mLoadInfo: true
# TODO: address inheritance somehow; there are aspects of HttpChannelChild that
# are interesting on their own.  We absolutely don't want to have to duplicate
# most things.  explicit inheritance seems useful, although the more concise
# the better.
mozilla::net::HttpChannelChild: mozilla::net::HttpBaseChannel
mozilla::net::nsHttpChannel: mozilla::net::HttpBaseChannel

nsStringInputStream:
  simple:
  - mData: true

nsBufferedInputStream:
  groups:
  - stream:
    - mStream: true
  - buffer:
    - mBufferSize: true
    - mBufferDisabled: true
    - mEOF: true
    - mBufferStartOffset: true
    - mCursor: true
    - mFillPoint: true
    - mGetBufferCount: true
    - mBuffer: true



nsMIMEInputStream:
  simple:
  - mHeaders: true
  - mStream: true

nsMultiplexInputStream:
  simple:
  - mCurrentStream: true
  - mStartedReadingCurrent: true
  - mStatus: true
  - mStreams: true

nsStorageInputStream:
  simple:
  - mStorageStream: true
  - mStatus: true
  # the cursors and such are dumb, forget them.

nsStorageStream:
  simple:
  - mLogicalLength: true
  - mSegmentedBuffer: true

nsPipeOutputStream:
  simple:
  # this probably needs / wants hierarchy awareness, or at least for us to have
  # loop detection if we want to add a binding for nsPipe that allows it to
  # reference the output streams.
  - mPipe: true
  - mBlocking: true
  - mBlocked: true

### DOM IPC ###

mozilla::dom::IdType:
  terse:
  - mId: true
# TODO: I think these want to both be extra terse displays that just amount to
# the typename and the mId.
mozilla::dom::ContentParentId: mozilla::dom::IdType
mozilla::dom::TabId: mozilla::dom::IdType

mozilla::dom::ContentParent:
  # characterize by type and pid.
  terse:
  - mRemoteType: true
  - mOtherPid: true

mozilla::dom::ContentProcessManager:
  simple:
  - mContentParentMap: true

# TODO: remove this type once our naive heuristics can handle the traversal
# automatically.
mozilla::dom::ContentProcessInfo:
  simple:
  - mCp: true
  - mParentCpId: true
  - mChildrenCpId: true
  - mRemoteFrames: true

mozilla::ipc::MessageChannel:
  terse:
  - mName: true
  - mChannelState: true
  - mPeerPid: true

mozilla::dom::IPCBlobInputStream:
  simple:
  - mState: true
  - mActor: true
  - mRemoteStream: true
mozilla::dom::IPCBlobInputStreamChild:
  simple:
  - mState: true
  - mSize: true
  - mOwningEventTarget: true
  - mWorkerHolder: true
  - mPendingOperations: true

### Core DOM ###

nsHTMLDocument:
  groups:
  - URIs:
    - mDocumentURI: true
    - mOriginalURI: true
  - state:
    - mReadyState: true
    - mVisibilityState: true
    - mOnloadBlockCount: true
    - mBFCacheEntry: true
    - mIsThirdParty: true
  - netish:
    - mChannel: true
  ##- perf:
  ##  - mTiming: true
  # for traversals?: mWindow,

### ServiceWorkers ###

mozilla::dom::workers::ServiceWorkerManagerService:
  simple:
    - mAgents: true
    - mPendingUpdaterActors: true

mozilla::dom::workers::ServiceWorkerManagerParent:
  simple:
    - mChannel: true
    - mID: true

mozilla::dom::workers::ServiceWorkerManager:
  groups:
  - registrations:
    - mRegistrationInfos: terse
  - documents:
    - mControlledDocuments: terse
    - mRegisteringDocuments: terse
  - interceptions:
    - mNavigationInterceptions: terse
  - startup:
    # - mActor: bool
    - mPendingOperations: terse
  - debugging:
    - mListeners: type

mozilla::dom::workers::ServiceWorkerManager::RegistrationDataPerPrincipal:
  simple:
  - mOrderedScopes: true
  - mInfos: true

mozilla::dom::workers::ServiceWorkerRegistrationInfo:
  groups:
  - state:
    - mScope: true
    - mUpdateState: true
  - workers:
    - mEvaluatingWorker: true
    - mActiveWorker: true
    - mWaitingWorker: true
    - mInstallingWorker: true

mozilla::dom::workers::ServiceWorkerInfo:
  simple:
  - mScope: true
  - mScriptSpec: true
  - mState: true
  - mSkipWaitingFlag: true
  - mHandlesFetch: true
